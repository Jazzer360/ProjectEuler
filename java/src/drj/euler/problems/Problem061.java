package drj.euler.problems;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import drj.euler.Answer;
import drj.euler.Problem;
import drj.euler.Utility;

/**
 * Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
 * are all figurate (polygonal) numbers and are generated by the following
 * formulae:
 * <pre>
 * Triangle	 	P3,n=n(n+1)/2	1, 3, 6, 10, 15, ...
 * Square		P4,n=n^2 		1, 4, 9, 16, 25, ...
 * Pentagonal	P5,n=n(3n-1)/2	1, 5, 12, 22, 35, ...
 * Hexagonal	P6,n=n(2n-1)	1, 6, 15, 28, 45, ...
 * Heptagonal	P7,n=n(5n-3)/2	1, 7, 18, 34, 55, ...
 * Octagonal	P8,n=n(3n-2)	1, 8, 21, 40, 65, ...</pre>
 * 
 * <p>The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
 * interesting properties.
 * 
 * <p>The set is cyclic, in that the last two digits of each number is the first
 * two digits of the next number (including the last number with the first).
 * 
 * <p>Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and
 * pentagonal (P5,44=2882), is represented by a different number in the set.
 * 
 * <p>This is the only set of 4-digit numbers with this property.
 * 
 * <p>Find the sum of the only ordered set of six cyclic 4-digit numbers for which
 * each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal,
 * and octagonal, is represented by a different number in the set.
 */
@Answer("28684")
public class Problem061 extends Problem {

	public static void main(String[] args) {
		Problem p = new Problem061();
		System.out.println(p);
	}

	private static Map<Integer, HashSet<Integer>> map = new HashMap<>();
	private static List<ArrayList<Integer>> chains = new ArrayList<>();

	@Override
	protected String onSolve() {
		Set<Integer> chainStarts = new HashSet<>();
		
		for (int i = 1_000; i < 10_000; i++) {
			if (isFigurate(i))
				addFigurate(i);
			if (Utility.isOctagonal(i))
				chainStarts.add(i);
		}
	
		for (int num : chainStarts) {
			createChains(num);
		}
	
		Iterator<ArrayList<Integer>> i = chains.iterator();
		while (i.hasNext()) {
			ArrayList<Integer> chain = i.next();
			if (!chainIsValid(chain)) {
				i.remove();
			}
		}
	
		int sum = 0;
		for (int n : chains.get(0)) {
			sum += n;
		}
		
		return String.valueOf(sum);
	}

	private static boolean isFigurate(int num) {
		if (Utility.isTriangular(num) || Utility.isSquare(num) ||
				Utility.isPentagonal(num) || Utility.isHexagonal(num) ||
				Utility.isHeptagonal(num) || Utility.isOctagonal(num)) {
			return true;
		}
		return false;
	}

	private static void addFigurate(int num) {
		int key = num / 100;
		if (!map.containsKey(key)) {
			HashSet<Integer> nums = new HashSet<>();
			nums.add(num);
			map.put(key, nums);
		} else {
			map.get(key).add(num);
		}
	}

	private static void createChains(int start) {
		ArrayList<Integer> chain = new ArrayList<>(6);

		chain.add(start);
		addLinks(chain);
	}

	private static void addLinks(ArrayList<Integer> chain) {
		int last = chain.get(chain.size() - 1);
		HashSet<Integer> nextLinks = map.get(last % 100);

		if (nextLinks == null)
			return;

		for (int num : nextLinks) {
			if (chain.size() == 6) {
				if (chain.get(0) == num) {
					chains.add(chain);
					return;
				}
			} else if (!chain.contains(num)) {
				ArrayList<Integer> nextChain = new ArrayList<>(6);
				nextChain.addAll(chain);
				nextChain.add(num);
				addLinks(nextChain);
			}
		}
	}

	private static boolean chainIsValid(ArrayList<Integer> chain) {
		ArrayList<Integer> figurateMasks = new ArrayList<>(6);
		figurateMasks.add(1<<8);

		for (int i = 1; i < chain.size(); i++) {
			figurateMasks.add(0);
			int num = chain.get(i);
			if (Utility.isOctagonal(num))
				figurateMasks.set(i, figurateMasks.get(i) | 1<<8);
			if (Utility.isHeptagonal(num))
				figurateMasks.set(i, figurateMasks.get(i) | 1<<7);
			if (Utility.isHexagonal(num))
				figurateMasks.set(i, figurateMasks.get(i) | 1<<6);
			if (Utility.isPentagonal(num))
				figurateMasks.set(i, figurateMasks.get(i) | 1<<5);
			if (Utility.isSquare(num))
				figurateMasks.set(i, figurateMasks.get(i) | 1<<4);
			if (Utility.isTriangular(num))
				figurateMasks.set(i, figurateMasks.get(i) | 1<<3);
		}

		isolateBits(figurateMasks);

		return figurateMasks.contains(0) ? false : true;
	}

	private static void isolateBits(ArrayList<Integer> masks) {
		int nonIsolatedBits = 0b1_1111_1000;
		while (nonIsolatedBits > 0) {
			int temp = nonIsolatedBits;

			for (int i = 0; i < masks.size(); i++) {
				int mask = masks.get(i);
				if ((mask & nonIsolatedBits) > 0
						&& Integer.bitCount(mask) == 1) {
					clearIsolatedBit(mask, i, masks);
					if (masks.contains(0)) return;
					nonIsolatedBits &= ~mask;
				}
			}

			if (temp == nonIsolatedBits) {
				int mask = Integer.highestOneBit(nonIsolatedBits);
				for (int i = 0; i < masks.size(); i++) {
					int maskAtPos = masks.get(i);
					if ((mask & maskAtPos) > 0) {
						masks.set(i, masks.get(i) & mask);
						clearIsolatedBit(mask, i, masks);
						nonIsolatedBits &= ~mask;
						break;
					}
				}
				if (temp == nonIsolatedBits) {
					nonIsolatedBits &= ~mask;
				}
			}
		}
	}

	private static void clearIsolatedBit(int mask, int maskIndex,
			ArrayList<Integer> masks) {
		for (int i = 0; i < masks.size(); i++) {
			if (i != maskIndex) {
				masks.set(i, masks.get(i) & ~mask);
			}
		}
	}
}
